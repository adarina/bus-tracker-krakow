{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/interaction/Snap\n */\n\n\nimport CollectionEventType from '../CollectionEventType.js';\nimport EventType from '../events/EventType.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport PointerInteraction from './Pointer.js';\nimport RBush from '../structs/RBush.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport { FALSE, TRUE } from '../functions.js';\nimport { boundingExtent, createEmpty } from '../extent.js';\nimport { closestOnCircle, closestOnSegment, squaredDistance } from '../coordinate.js';\nimport { fromCircle } from '../geom/Polygon.js';\nimport { fromUserCoordinate, getUserProjection, toUserCoordinate } from '../proj.js';\nimport { getUid } from '../util.js';\nimport { getValues } from '../obj.js';\nimport { listen, unlistenByKey } from '../events.js';\n/**\n * @typedef {Object} Result\n * @property {import(\"../coordinate.js\").Coordinate|null} vertex Vertex.\n * @property {import(\"../pixel.js\").Pixel|null} vertexPixel VertexPixel.\n */\n\n/**\n * @typedef {Object} SegmentData\n * @property {import(\"../Feature.js\").default} feature Feature.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} segment Segment.\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../Collection.js\").default<import(\"../Feature.js\").default>} [features] Snap to these features. Either this option or source should be provided.\n * @property {boolean} [edge=true] Snap to edges.\n * @property {boolean} [vertex=true] Snap to vertices.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\n * vertex for snapping.\n * @property {import(\"../source/Vector.js\").default} [source] Snap to features from this source. Either this option or features should be provided\n */\n\n/**\n * @param  {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n * @return {import(\"../Feature.js\").default} Feature.\n */\n\nfunction getFeatureFromEvent(evt) {\n  if (\n  /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */\n  evt.feature) {\n    return (\n      /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */\n      evt.feature\n    );\n  } else if (\n  /** @type {import(\"../Collection.js\").CollectionEvent} */\n  evt.element) {\n    return (\n      /** @type {import(\"../Feature.js\").default} */\n\n      /** @type {import(\"../Collection.js\").CollectionEvent} */\n      evt.element\n    );\n  }\n}\n\nvar tempSegment = [];\n/**\n * @classdesc\n * Handles snapping of vector features while modifying or drawing them.  The\n * features can come from a {@link module:ol/source/Vector~VectorSource} or {@link module:ol/Collection~Collection}\n * Any interaction object that allows the user to interact\n * with the features using the mouse can benefit from the snapping, as long\n * as it is added before.\n *\n * The snap interaction modifies map browser event `coordinate` and `pixel`\n * properties to force the snap to occur to any interaction that them.\n *\n * Example:\n *\n *     import Snap from 'ol/interaction/Snap';\n *\n *     const snap = new Snap({\n *       source: source\n *     });\n *\n *     map.addInteraction(snap);\n *\n * @api\n */\n\nvar Snap =\n/** @class */\nfunction (_super) {\n  __extends(Snap, _super);\n  /**\n   * @param {Options} [opt_options] Options.\n   */\n\n\n  function Snap(opt_options) {\n    var _this = this;\n\n    var options = opt_options ? opt_options : {};\n    var pointerOptions =\n    /** @type {import(\"./Pointer.js\").Options} */\n    options;\n\n    if (!pointerOptions.handleDownEvent) {\n      pointerOptions.handleDownEvent = TRUE;\n    }\n\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    _this = _super.call(this, pointerOptions) || this;\n    /**\n     * @type {import(\"../source/Vector.js\").default|null}\n     * @private\n     */\n\n    _this.source_ = options.source ? options.source : null;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    _this.vertex_ = options.vertex !== undefined ? options.vertex : true;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    _this.edge_ = options.edge !== undefined ? options.edge : true;\n    /**\n     * @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|null}\n     * @private\n     */\n\n    _this.features_ = options.features ? options.features : null;\n    /**\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     * @private\n     */\n\n    _this.featuresListenerKeys_ = [];\n    /**\n     * @type {Object<string, import(\"../events.js\").EventsKey>}\n     * @private\n     */\n\n    _this.featureChangeListenerKeys_ = {};\n    /**\n     * Extents are preserved so indexed segment can be quickly removed\n     * when its feature geometry changes\n     * @type {Object<string, import(\"../extent.js\").Extent>}\n     * @private\n     */\n\n    _this.indexedFeaturesExtents_ = {};\n    /**\n     * If a feature geometry changes while a pointer drag|move event occurs, the\n     * feature doesn't get updated right away.  It will be at the next 'pointerup'\n     * event fired.\n     * @type {!Object<string, import(\"../Feature.js\").default>}\n     * @private\n     */\n\n    _this.pendingFeatures_ = {};\n    /**\n     * @type {number}\n     * @private\n     */\n\n    _this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n    /**\n     * Segment RTree for each layer\n     * @type {import(\"../structs/RBush.js\").default<SegmentData>}\n     * @private\n     */\n\n    _this.rBush_ = new RBush();\n    /**\n     * @const\n     * @private\n     * @type {Object<string, function(Array<Array<import('../coordinate.js').Coordinate>>, import(\"../geom/Geometry.js\").default): void>}\n     */\n\n    _this.GEOMETRY_SEGMENTERS_ = {\n      'Point': _this.segmentPointGemetry_.bind(_this),\n      'LineString': _this.segmentLineStringGemetry_.bind(_this),\n      'LinearRing': _this.segmentLineStringGemetry_.bind(_this),\n      'Polygon': _this.segmentPolygonGemetry_.bind(_this),\n      'MultiPoint': _this.segmentMultiPointGemetry_.bind(_this),\n      'MultiLineString': _this.segmentMultiLineStringGemetry_.bind(_this),\n      'MultiPolygon': _this.segmentMultiPolygonGemetry_.bind(_this),\n      'GeometryCollection': _this.segmentGeometryCollectionGemetry_.bind(_this),\n      'Circle': _this.segmentCircleGemetry_.bind(_this)\n    };\n    return _this;\n  }\n  /**\n   * Add a feature to the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {boolean} [opt_listen] Whether to listen to the feature change or not\n   *     Defaults to `true`.\n   * @api\n   */\n\n\n  Snap.prototype.addFeature = function (feature, opt_listen) {\n    var register = opt_listen !== undefined ? opt_listen : true;\n    var feature_uid = getUid(feature);\n    var geometry = feature.getGeometry();\n\n    if (geometry) {\n      var segmenter = this.GEOMETRY_SEGMENTERS_[geometry.getType()];\n\n      if (segmenter) {\n        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(createEmpty());\n        var segments =\n        /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */\n        [];\n        segmenter(segments, geometry);\n\n        if (segments.length === 1) {\n          this.rBush_.insert(boundingExtent(segments[0]), {\n            feature: feature,\n            segment: segments[0]\n          });\n        } else if (segments.length > 1) {\n          var extents = segments.map(function (s) {\n            return boundingExtent(s);\n          });\n          var segmentsData = segments.map(function (segment) {\n            return {\n              feature: feature,\n              segment: segment\n            };\n          });\n          this.rBush_.load(extents, segmentsData);\n        }\n      }\n    }\n\n    if (register) {\n      this.featureChangeListenerKeys_[feature_uid] = listen(feature, EventType.CHANGE, this.handleFeatureChange_, this);\n    }\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n\n\n  Snap.prototype.forEachFeatureAdd_ = function (feature) {\n    this.addFeature(feature);\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n\n\n  Snap.prototype.forEachFeatureRemove_ = function (feature) {\n    this.removeFeature(feature);\n  };\n  /**\n   * @return {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} Features.\n   * @private\n   */\n\n\n  Snap.prototype.getFeatures_ = function () {\n    var features;\n\n    if (this.features_) {\n      features = this.features_;\n    } else if (this.source_) {\n      features = this.source_.getFeatures();\n    }\n\n    return features;\n  };\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n\n\n  Snap.prototype.handleEvent = function (evt) {\n    var result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n\n    if (result) {\n      evt.coordinate = result.vertex.slice(0, 2);\n      evt.pixel = result.vertexPixel;\n    }\n\n    return _super.prototype.handleEvent.call(this, evt);\n  };\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n   * @private\n   */\n\n\n  Snap.prototype.handleFeatureAdd_ = function (evt) {\n    var feature = getFeatureFromEvent(evt);\n    this.addFeature(feature);\n  };\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n   * @private\n   */\n\n\n  Snap.prototype.handleFeatureRemove_ = function (evt) {\n    var feature = getFeatureFromEvent(evt);\n    this.removeFeature(feature);\n  };\n  /**\n   * @param {import(\"../events/Event.js\").default} evt Event.\n   * @private\n   */\n\n\n  Snap.prototype.handleFeatureChange_ = function (evt) {\n    var feature =\n    /** @type {import(\"../Feature.js\").default} */\n    evt.target;\n\n    if (this.handlingDownUpSequence) {\n      var uid = getUid(feature);\n\n      if (!(uid in this.pendingFeatures_)) {\n        this.pendingFeatures_[uid] = feature;\n      }\n    } else {\n      this.updateFeature_(feature);\n    }\n  };\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   * @return {boolean} If the event was consumed.\n   */\n\n\n  Snap.prototype.handleUpEvent = function (evt) {\n    var featuresToUpdate = getValues(this.pendingFeatures_);\n\n    if (featuresToUpdate.length) {\n      featuresToUpdate.forEach(this.updateFeature_.bind(this));\n      this.pendingFeatures_ = {};\n    }\n\n    return false;\n  };\n  /**\n   * Remove a feature from the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {boolean} [opt_unlisten] Whether to unlisten to the feature change\n   *     or not. Defaults to `true`.\n   * @api\n   */\n\n\n  Snap.prototype.removeFeature = function (feature, opt_unlisten) {\n    var unregister = opt_unlisten !== undefined ? opt_unlisten : true;\n    var feature_uid = getUid(feature);\n    var extent = this.indexedFeaturesExtents_[feature_uid];\n\n    if (extent) {\n      var rBush = this.rBush_;\n      var nodesToRemove_1 = [];\n      rBush.forEachInExtent(extent, function (node) {\n        if (feature === node.feature) {\n          nodesToRemove_1.push(node);\n        }\n      });\n\n      for (var i = nodesToRemove_1.length - 1; i >= 0; --i) {\n        rBush.remove(nodesToRemove_1[i]);\n      }\n    }\n\n    if (unregister) {\n      unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n      delete this.featureChangeListenerKeys_[feature_uid];\n    }\n  };\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../PluggableMap.js\").default} map Map.\n   */\n\n\n  Snap.prototype.setMap = function (map) {\n    var currentMap = this.getMap();\n    var keys = this.featuresListenerKeys_;\n    var features =\n    /** @type {Array<import(\"../Feature.js\").default>} */\n    this.getFeatures_();\n\n    if (currentMap) {\n      keys.forEach(unlistenByKey);\n      keys.length = 0;\n      features.forEach(this.forEachFeatureRemove_.bind(this));\n    }\n\n    _super.prototype.setMap.call(this, map);\n\n    if (map) {\n      if (this.features_) {\n        keys.push(listen(this.features_, CollectionEventType.ADD, this.handleFeatureAdd_, this), listen(this.features_, CollectionEventType.REMOVE, this.handleFeatureRemove_, this));\n      } else if (this.source_) {\n        keys.push(listen(this.source_, VectorEventType.ADDFEATURE, this.handleFeatureAdd_, this), listen(this.source_, VectorEventType.REMOVEFEATURE, this.handleFeatureRemove_, this));\n      }\n\n      features.forEach(this.forEachFeatureAdd_.bind(this));\n    }\n  };\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel\n   * @param {import(\"../coordinate.js\").Coordinate} pixelCoordinate Coordinate\n   * @param {import(\"../PluggableMap.js\").default} map Map.\n   * @return {Result|null} Snap result\n   */\n\n\n  Snap.prototype.snapTo = function (pixel, pixelCoordinate, map) {\n    var lowerLeft = map.getCoordinateFromPixel([pixel[0] - this.pixelTolerance_, pixel[1] + this.pixelTolerance_]);\n    var upperRight = map.getCoordinateFromPixel([pixel[0] + this.pixelTolerance_, pixel[1] - this.pixelTolerance_]);\n    var box = boundingExtent([lowerLeft, upperRight]);\n    var segments = this.rBush_.getInExtent(box);\n    var segmentsLength = segments.length;\n\n    if (segmentsLength === 0) {\n      return null;\n    }\n\n    var projection = map.getView().getProjection();\n    var projectedCoordinate = fromUserCoordinate(pixelCoordinate, projection);\n    var closestVertex;\n    var minSquaredDistance = Infinity;\n    var squaredPixelTolerance = this.pixelTolerance_ * this.pixelTolerance_;\n\n    var getResult = function () {\n      if (closestVertex) {\n        var vertexPixel = map.getPixelFromCoordinate(closestVertex);\n        var squaredPixelDistance = squaredDistance(pixel, vertexPixel);\n\n        if (squaredPixelDistance <= squaredPixelTolerance) {\n          return {\n            vertex: closestVertex,\n            vertexPixel: [Math.round(vertexPixel[0]), Math.round(vertexPixel[1])]\n          };\n        }\n      }\n\n      return null;\n    };\n\n    if (this.vertex_) {\n      for (var i = 0; i < segmentsLength; ++i) {\n        var segmentData = segments[i];\n\n        if (segmentData.feature.getGeometry().getType() !== GeometryType.CIRCLE) {\n          segmentData.segment.forEach(function (vertex) {\n            var tempVertexCoord = fromUserCoordinate(vertex, projection);\n            var delta = squaredDistance(projectedCoordinate, tempVertexCoord);\n\n            if (delta < minSquaredDistance) {\n              closestVertex = vertex;\n              minSquaredDistance = delta;\n            }\n          });\n        }\n      }\n\n      var result = getResult();\n\n      if (result) {\n        return result;\n      }\n    }\n\n    if (this.edge_) {\n      for (var i = 0; i < segmentsLength; ++i) {\n        var vertex = null;\n        var segmentData = segments[i];\n\n        if (segmentData.feature.getGeometry().getType() === GeometryType.CIRCLE) {\n          var circleGeometry = segmentData.feature.getGeometry();\n          var userProjection = getUserProjection();\n\n          if (userProjection) {\n            circleGeometry = circleGeometry.clone().transform(userProjection, projection);\n          }\n\n          vertex = toUserCoordinate(closestOnCircle(projectedCoordinate,\n          /** @type {import(\"../geom/Circle.js\").default} */\n          circleGeometry), projection);\n        } else {\n          var _a = segmentData.segment,\n              segmentStart = _a[0],\n              segmentEnd = _a[1]; // points have only one coordinate\n\n          if (segmentEnd) {\n            tempSegment[0] = fromUserCoordinate(segmentStart, projection);\n            tempSegment[1] = fromUserCoordinate(segmentEnd, projection);\n            vertex = closestOnSegment(projectedCoordinate, tempSegment);\n          }\n        }\n\n        if (vertex) {\n          var delta = squaredDistance(projectedCoordinate, vertex);\n\n          if (delta < minSquaredDistance) {\n            closestVertex = vertex;\n            minSquaredDistance = delta;\n          }\n        }\n      }\n\n      var result = getResult();\n\n      if (result) {\n        return result;\n      }\n    }\n\n    return null;\n  };\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @private\n   */\n\n\n  Snap.prototype.updateFeature_ = function (feature) {\n    this.removeFeature(feature, false);\n    this.addFeature(feature, false);\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.segmentCircleGemetry_ = function (segments, geometry) {\n    var projection = this.getMap().getView().getProjection();\n    var circleGeometry = geometry;\n    var userProjection = getUserProjection();\n\n    if (userProjection) {\n      circleGeometry =\n      /** @type {import(\"../geom/Circle.js\").default} */\n      circleGeometry.clone().transform(userProjection, projection);\n    }\n\n    var polygon = fromCircle(circleGeometry);\n\n    if (userProjection) {\n      polygon.transform(projection, userProjection);\n    }\n\n    var coordinates = polygon.getCoordinates()[0];\n\n    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segments.push(coordinates.slice(i, i + 2));\n    }\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.segmentGeometryCollectionGemetry_ = function (segments, geometry) {\n    var geometries = geometry.getGeometriesArray();\n\n    for (var i = 0; i < geometries.length; ++i) {\n      var segmenter = this.GEOMETRY_SEGMENTERS_[geometries[i].getType()];\n\n      if (segmenter) {\n        segmenter(segments, geometries[i]);\n      }\n    }\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.segmentLineStringGemetry_ = function (segments, geometry) {\n    var coordinates = geometry.getCoordinates();\n\n    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segments.push(coordinates.slice(i, i + 2));\n    }\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.segmentMultiLineStringGemetry_ = function (segments, geometry) {\n    var lines = geometry.getCoordinates();\n\n    for (var j = 0, jj = lines.length; j < jj; ++j) {\n      var coordinates = lines[j];\n\n      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.segmentMultiPointGemetry_ = function (segments, geometry) {\n    geometry.getCoordinates().forEach(function (point) {\n      segments.push([point]);\n    });\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.segmentMultiPolygonGemetry_ = function (segments, geometry) {\n    var polygons = geometry.getCoordinates();\n\n    for (var k = 0, kk = polygons.length; k < kk; ++k) {\n      var rings = polygons[k];\n\n      for (var j = 0, jj = rings.length; j < jj; ++j) {\n        var coordinates = rings[j];\n\n        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          segments.push(coordinates.slice(i, i + 2));\n        }\n      }\n    }\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.segmentPointGemetry_ = function (segments, geometry) {\n    segments.push([geometry.getCoordinates()]);\n  };\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n   * @private\n   */\n\n\n  Snap.prototype.segmentPolygonGemetry_ = function (segments, geometry) {\n    var rings = geometry.getCoordinates();\n\n    for (var j = 0, jj = rings.length; j < jj; ++j) {\n      var coordinates = rings[j];\n\n      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n  };\n\n  return Snap;\n}(PointerInteraction);\n\nexport default Snap; //# sourceMappingURL=Snap.js.map","map":null,"metadata":{},"sourceType":"module"}